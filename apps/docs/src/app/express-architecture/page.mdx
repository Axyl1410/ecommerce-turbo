# Express app architecture

This page captures the current Clean Architecture layout of `apps/express`. Use it as a map when you need to trace an endpoint, identify where to add new logic, or explain the layering to teammates.

---

## Layer overview

| Layer | Location | Purpose |
| --- | --- | --- |
| **Domain** | `apps/express/src/domain` | Entities, value objects, repository contracts, domain services |
| **Application** | `apps/express/src/application` | Use cases, DTOs, cache/interface contracts |
| **Infrastructure** | `apps/express/src/infrastructure` | Prisma repositories, Redis cache, DI container, adapters |
| **Presentation** | `apps/express/src/presentation` | Controllers, validators, Express routers |
| **Routes** | `apps/express/src/routes/v1` | Entry points mounted by the main server |
| **Shared** | `apps/express/src/shared` | Common errors, helpers (e.g., API response helpers) |

Each request flows Presentation → Application → Domain, with Infrastructure providing concrete implementations via dependency injection.

---

## Directory map

```
apps/express/src
├── domain
│   ├── entities/              # Product, Cart, CartItem …
│   ├── value-objects/         # Price, Slug, etc.
│   ├── repositories/          # Interfaces consumed by use cases
│   └── services/              # Cross-entity domain services (e.g., cart merge)
├── application
│   ├── dto/                   # Input/output contracts for use cases
│   ├── interfaces/            # Cache abstraction and other ports
│   └── use-cases/
│       ├── product/           # CRUD + query use cases
│       └── cart/              # Cart lifecycle + item operations
├── infrastructure
│   ├── cache/                 # Redis cache implementation
│   ├── di/                    # Manual DI container wiring every dependency
│   └── persistence/
│       └── prisma/            # Prisma repositories mapping DB → domain
├── presentation
│   ├── controllers/           # HTTP orchestration + error translation
│   ├── validators/            # Zod schemas for body/query params
│   └── routes/
│       └── v1/                # Express Router definitions (product, cart)
├── routes/
│   └── v1/index.ts            # Mounts versioned routers + health endpoints
└── shared/
    ├── errors/                # DomainError, ApplicationError, NotFoundError
    └── lib/                   # API response helper, logging, etc.
```

---

## Dependency injection

- `apps/express/src/infrastructure/di/container.ts` instantiates Prisma repositories, Redis cache, and every use case.
- Controllers are constructed with their required use cases and registered under descriptive keys (`productController`, `cartController`).
- `apps/express/src/routes/v1/index.ts` pulls controllers from the container so routes stay framework-only.

This manual DI container keeps wiring in one place, letting tests replace dependencies or future modules plug into the same pattern.

---

## Request flow example

For `GET /api/v1/cart`:

1. `routes/v1/index.ts` mounts `createCartRoutes`.
2. `presentation/routes/v1/cart.routes.ts` resolves the user/session identifier and invokes `CartController.getCart`.
3. `CartController` calls `GetOrCreateCartUseCase` (ensures cart, merges guest → user) then `GetCartDetailsUseCase`.
4. Use cases rely on `ICartRepository`/`ICacheService`, supplied by `PrismaCartRepository` and `RedisCacheService`.
5. Responses flow back via the shared API helper, keeping consistent `{ result, message, data }` payloads.

---

## When adding new features

1. **Start in Domain** – Define entities/value objects or extend repository interfaces.
2. **Add a use case** – Place orchestration logic in `application/use-cases/<module>`.
3. **Implement infrastructure** – Extend the Prisma repository or add new adapters.
4. **Expose via presentation** – Create controller methods/validators/routes.
5. **Wire it up** – Register the new use case + controller method in the DI container and route index.

Following these steps keeps the Clean Architecture boundaries intact and makes future refactors safer.

---

## Prisma queries + Drizzle types

We use Prisma for querying (rich `include`/`select`/`orderBy`) but keep Drizzle schema/types as the single source of truth. Prisma cannot emit `typeof Product.$inferSelect`, so we map the results.

### 1) Export Drizzle row/insert types

In `packages/types/src/drizzle/schema.ts`:

```
export type ProductRow = typeof Product.$inferSelect;
export type ProductInsert = typeof Product.$inferInsert;
```

Then re-export in `packages/types/src/index.ts`:

```
export type { ProductRow, ProductInsert } from "./drizzle/schema.js";
```

### 2) Query with Prisma, map to Drizzle type

In `apps/express/src/infrastructure/persistence/prisma/product.repository.impl.ts`:

```
import { prisma } from "@workspace/database";
import type { ProductRow } from "@workspace/types";

const productsPrisma = await prisma.product.findMany({
  where,
  skip: (page - 1) * limit,
  take: limit,
  orderBy: { [sortBy]: sortOrder },
});

const products: ProductRow[] = productsPrisma.map((product) => ({
  ...product,
  // Convert special fields here if needed (e.g., Decimal → number, JSON parsing).
}));
```

If you wrap rows in domain entities, map `ProductRow` through your entity factory in a `toDomain` helper before returning.

### 3) Use Drizzle enums with Prisma

Drizzle/domain enums (e.g., `ProductStatusEnum`) are strings, so they work directly in Prisma filters:

```
import { ProductStatusEnum } from "@workspace/types";

await prisma.product.findMany({
  where: { status: ProductStatusEnum.PUBLISHED },
});
```

Outcome: Prisma remains the query tool; Drizzle schema remains the domain/type source. Mapping keeps types aligned without forcing Prisma to understand Drizzle tables.


